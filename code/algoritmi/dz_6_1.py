"""
Задание 1.
Выполните профилирование памяти в скриптах.
Проанализируйте результат и определите программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.
Можно взять только домашние задания с курса Основ
или с текущего курса Алгоритмов
Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)
ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!

"""

#  Задание 1.1
"""
 Урок 1 из курса "Основы Python"
Создать список, состоящий из кубов нечётных чисел от 0 до 1000 (в решении предлагается 100 000):
Вычислить сумму тех чисел из этого списка, сумма цифр которых делится нацело на 7. Например, число «19 ^ 3 = 6859»
будем включать в сумму, так как 6 + 8 + 5 + 9 = 28 – делится нацело на 7.
Внимание: использовать только арифметические операции!
К каждому элементу списка добавить 17 и заново вычислить сумму тех чисел из этого списка, сумма цифр которых
делится нацело на 7. Внимание: новый список не создавать!!!
 """
from memory_profiler import memory_usage
from timeit import default_timer

""" Функция - декоратор"""


def memory(func):
    def wrapper(*args, **kwargs):
        start_time = default_timer()
        m1 = memory_usage()
        res_f = func(args[0])
        m2 = memory_usage()
        mem_diff = m2[0] - m1[0]
        time_diff = default_timer() - start_time
        return res_f, round(mem_diff, 4), round(time_diff, 4)

    return wrapper


# Базовое решение

@memory
def basic_solution(n):
    list_cub = list()
    sum_one = 0
    sum_two = 0
    for val in range(1, n, 2):
        val_in_list = val ** 3
        list_cub.append(val_in_list)
        digit = val_in_list
        sum_digits = 0
        while digit != 0:
            sum_digits += digit % 10
            digit = digit // 10
        if sum_digits % 7 == 0:
            sum_one += val_in_list
    print('Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна: ', sum_one)

    for index_list in range(len(list_cub)):
        list_cub[index_list] += 17
        val_in_list = list_cub[index_list]
        digit = val_in_list
        sum_digits = 0
        while digit != 0:
            sum_digits += digit % 10
            digit = digit // 10
        if sum_digits % 7 == 0:
            sum_two += val_in_list
    print('Сумма чисел из списка после добавления 17, сумма цифр которых делится нацело на 7, будет равна: ',
          sum_two)
    return sum_one, sum_two


# --------------------------------- Оптимицированные решения ------------------------------------------------


""" 2.1 LC по всему списку + условие в цикле """


@memory
def lc_solution(n):
    sum_one = 0
    sum_two = 0
    lc_val = [i ** 3 for i in range(1, n, 2)]
    for val in lc_val:
        sum_one += val if sum(map(int, list(str(val)))) % 7 == 0 else 0
        sum_two += val if sum(map(int, list(str(val + 17)))) % 7 == 0 else 0
    print('Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна: ', sum_one)
    print('Сумма чисел из списка, увеличенная на 17, сумма цифр которых делится нацело на 7, будет равна: ', sum_two)
    return sum_one, sum_two


# 2.1 LC по всему списку c условием

@memory
def lc_solution_2(n):
    sum_one = 0
    sum_two = 0
    lc_val = [i ** 3 for i in range(1, n, 2) if sum(map(int, list(str(i ** 3)))) % 7 == 0]
    lc_val_st = [(i ** 3 + 17) for i in range(1, n, 2) if sum(map(int, list(str((i ** 3 + 17))))) % 7 == 0]
    for val in lc_val:
        sum_one += val
    for val in lc_val_st:
        sum_two += val
    print('Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна: ', sum_one)
    print('Сумма чисел из списка, увеличенная на 17, сумма цифр которых делится нацело на 7, будет равна: ', sum_two)
    return sum_one, sum_two


# 3.1 Генератор по всему списку + условие в цикле

@memory
def gen_solution(n):
    sum_one = 0
    sum_two = 0
    gen_val = (i ** 3 for i in range(1, n, 2))
    for val in gen_val:
        sum_one += val if sum(map(int, list(str(val)))) % 7 == 0 else 0
        sum_two += val if sum(map(int, list(str(val + 17)))) % 7 == 0 else 0
    print('Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна: ', sum_one)
    print('Сумма чисел из списка, увеличенная на 17, сумма цифр которых делится нацело на 7, будет равна: ', sum_two)
    return sum_one, sum_two


# 3.2 Генератор с условием

@memory
def gen_solution_2(n):
    sum_one = 0
    sum_two = 0
    gen_val = (i ** 3 for i in range(1, n, 2) if sum(map(int, list(str(i ** 3)))) % 7 == 0)
    gen_val_st = [(i ** 3 + 17) for i in range(1, n, 2) if sum(map(int, list(str((i ** 3 + 17))))) % 7 == 0]
    for val in gen_val:
        sum_one += val
    for val in gen_val_st:
        sum_two += val
    print('Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна: ', sum_one)
    print('Сумма чисел из списка, увеличенная на 17, сумма цифр которых делится нацело на 7, будет равна: ', sum_two)
    return sum_one, sum_two


if __name__ == '__main__':
    num = 10000
    print('\n', '-' * 15, '1. Базовое решение')
    res = basic_solution(num)
    print(f'Выполнение заняло: {res[1]} Mib и {res[2]} по времени.')

    print('\n', '-' * 15, '2.1 LC по всему списку + условие в цикле')
    res = lc_solution(num)
    print(f'Выполнение заняло: {res[1]} Mib и {res[2]} по времени.')

    print('\n', '-' * 15, '2.2 LC c условием')
    res = lc_solution_2(num)
    print(f'Выполнение заняло: {res[1]} Mib и {res[2]} по времени.')

    print('\n', '-' * 15, '3.1 Генератор по всему списку + условие в цикле')
    res = gen_solution(num)
    print(f'Выполнение заняло: {res[1]} Mib и {res[2]} по времени.')

    print('\n', '-' * 15, '3.2 Генератор с условием')
    res = gen_solution_2(num)
    print(f'Выполнение заняло: {res[1]} Mib и {res[2]} по времени.')

""" 
Выводы: 
Базовый вариант из основ, сделанный с учетом ограничений урока (т.е. функционал урока и не более), 
предполагает, то все операции будут выполняться с заранее созданным списком. Это требует использования памяти.
Учитывая то, что условие задачи предполагает повторную коррекцию исходных данных, предполагающую увеличение значений 
в исходном списке, на втором этапе из памяти будет выделен дополнительный объем.
Использование вариантов с LC по всему списку с последующим IF позволило уменьшить объем 
используемой памяти практически в два раза за счет исключения циклов с заданными диапазонами при обработке значений.
Вариант LC c условием, где предполагается формирование готового списка с данными, получился еще экономичнее по памяти
за счет того, что они хранят не полный список, а отфильтрованные значения. 
Варианты с генераторами в обоих случаях показали одинаковые результаты по использованию памяти - 0.0 MiB (близкое к 0), 
т.к. они не предполагают хранение массива, а выдачу данных по мере необходимости.
По времени вычислений все варианты реализация для данной задачи получились примерно одинаковыми, но на больших объемах
данных для менее экономичных вариантов по памяти будет наблюдаться большая эффективность по времени
за счет возможности повторного использования сохраненных в памяти списков - см. результат при n = 1000 000    
1. Результаты замеров при n = 100 000 получились следующие:
 --------------- 1. Базовое решение
Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна:  1409831608061185538
Сумма чисел из списка после добавления 17, сумма цифр которых делится нацело на 7, будет равна:  2574098230465251076
Выполнение заняло: 0.5469 Mib и 0.4706 по времени.
 --------------- 2.1 LC по всему списку + условие в цикле
Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна:  1409831608061185538
Сумма чисел из списка, увеличенная на 17, сумма цифр которых делится нацело на 7, будет равна:  2574098230465088216
Выполнение заняло: 0.3086 Mib и 0.4724 по времени.
 --------------- 2.2 LC c условием
Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна:  1409831608061185538
Сумма чисел из списка, увеличенная на 17, сумма цифр которых делится нацело на 7, будет равна:  2574098230465251076
Выполнение заняло: 0.0117 Mib и 0.4986 по времени.
 --------------- 3.1 Генератор по всему списку + условие в цикле
Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна:  1409831608061185538
Сумма чисел из списка, увеличенная на 17, сумма цифр которых делится нацело на 7, будет равна:  2574098230465088216
Выполнение заняло: 0.0 Mib и 0.4906 по времени.
 --------------- 3.2 Генератор с условием
Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна:  1409831608061185538
Сумма чисел из списка, увеличенная на 17, сумма цифр которых делится нацело на 7, будет равна:  2574098230465251076
Выполнение заняло: 0.0 Mib и 0.4926 по времени.
2. Результаты замеров  при n = 1 000 000 получились следующие:
 --------------- 1. Базовое решение
Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна:  18446520627798932667264
Сумма чисел из списка после добавления 17, сумма цифр которых делится нацело на 7, будет равна:  16547510776428693608260
Выполнение заняло: 1.6133 Mib и 2.7155 по времени.
 --------------- 2.1 LC по всему списку + условие в цикле
Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна:  18446520627798932667264
Сумма чисел из списка, увеличенная на 17, сумма цифр которых делится нацело на 7, будет равна:  16547510776428692267266
Выполнение заняло: -0.707 Mib и 3.1288 по времени.
 --------------- 2.2 LC c условием
Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна:  18446520627798932667264
Сумма чисел из списка, увеличенная на 17, сумма цифр которых делится нацело на 7, будет равна:  16547510776428693608260
Выполнение заняло: -0.043 Mib и 3.6685 по времени.
 --------------- 3.1 Генератор по всему списку + условие в цикле
Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна:  18446520627798932667264
Сумма чисел из списка, увеличенная на 17, сумма цифр которых делится нацело на 7, будет равна:  16547510776428692267266
Выполнение заняло: 0.0 Mib и 3.1219 по времени.
 --------------- 3.2 Генератор с условием
Сумма чисел из списка, сумма цифр которых делится нацело на 7, будет равна:  18446520627798932667264
Сумма чисел из списка, увеличенная на 17, сумма цифр которых делится нацело на 7, будет равна:  16547510776428693608260
Выполнение заняло: -0.1211 Mib и 3.4715 по времени.
"""

# --------------------------------------------------------------------------------------------

"""
Задание №1 из Lesson-4 по алгоритмам.
Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива.

"""

from memory_profiler import memory_usage
from timeit import default_timer
from numpy import array

""" Функция-декоратор """


def info_memory(func):
    def wrapper(*args, **kwargs):
        start_time = default_timer()
        m_one = memory_usage()
        res_f = func(*args)
        m_two = memory_usage()
        diff = m_two[0] - m_one[0]
        time_diff = default_timer() - start_time
        return round(diff, 4), round(time_diff, 4)

    return wrapper


""" Вариант с циклом """


@info_memory
def func_1(nums):
    arr_new = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            arr_new.append(i)
    return arr_new


""" Вариант с list comprehension """


@info_memory
def func_lc(nums):
    arr_new = [i for i in range(len(nums)) if nums[i] % 2 == 0]
    return arr_new


""" Генератор в список """


@info_memory
def func_gen_list(nums):
    gen_index = (i for i in range(len(nums)) if nums[i] % 2 == 0)
    arr_new = [i for i in gen_index]  # можно было просто extend()
    return arr_new


""" Генератор """


@info_memory
def func_only_gen(nums):
    arr_new_gen = (i for i in range(len(nums)) if nums[i] % 2 == 0)
    return arr_new_gen


""" Array из NumPy """


@info_memory
def func_numpy(nums):
    arr_new = array([i for i in range(len(nums)) if nums[i] % 2 == 0])
    return arr_new


""" Проверяем созданные функции. """
n = list(range(10000000))

print("\n --------------- Замеры к заданию №1 из Lesson-4 по алгоритмам при n = 10000000: ")
print("Цикл.     - Время: {0}   Память: {1}".format(*func_1(n)))
print("LC.       - Время: {0}   Память: {1}".format(*func_lc(n)))
print('Ген и LC. - Время: {0}   Память: {1}'.format(*func_gen_list(n)))
print('Ген.      - Время: {0}   Память: {1}'.format(*func_only_gen(n)))
print('NumPy.    - Время: {0}   Память: {1}'.format(*func_numpy(n)))

"""
Вывод:
В данном примере по памяти выигрывает генератор и NumPy. 
По скорости выигрывает NumPy, если нужен массив с готовыми данными, а если не нужен, то генератор. 
 --------------- Замеры к заданию №1 из Lesson-4 по алгоритмам при n = 10000000: 
Цикл.     - Время: 193.5039   Память: 0.828
LC.       - Время: 192.9375   Память: 0.7242
Ген и LC. - Время: 193.8477   Память: 0.8607
Ген.      - Время: 0.0   Память: 0.2203
NumPy.    - Время: 18.0391   Память: 1.0512

"""
